import{_ as a,c as o,m as e,a as n,t as r,V as i,o as s}from"./chunks/framework.rMwTSdrC.js";const k=JSON.parse('{"title":"Section 0: Coding Smarter with Online Tools","description":"","frontmatter":{"layout":"doc","title":"Section 0: Coding Smarter with Online Tools","sidebar":true,"aside":true},"headers":[],"relativePath":"sections/chatgpt-and-llms/index.md","filePath":"sections/chatgpt-and-llms/index.md"}'),l={name:"sections/chatgpt-and-llms/index.md"},c={id:"frontmatter-title",tabindex:"-1"},h=e("a",{class:"header-anchor",href:"#frontmatter-title","aria-label":'Permalink to "{{ $frontmatter.title }}"'},"​",-1),d=i('<p>I&#39;ve spent a lot of time helping people troubleshoot programming issues, do data analysis, and get set up computationally. If you interviewed people about this experience, a common theme would emerge; I spend a lot of time asking the internet for help. Whether it&#39;s a forum like <a href="https://stackoverflow.com/" target="_blank" rel="noreferrer">Stack Overflow</a> or an AI chatbot like <a href="https://openai.com/chatgpt/" target="_blank" rel="noreferrer">ChatGPT</a>, you can figure out anything with the internet.</p><p>When it comes to programming, my philosophy is that <strong>it&#39;s much more important to grasp a concept than commit specifics to memory</strong>. If you understand the concept behind what you&#39;re trying to accomplish, the internet will always be able to fill in the specifics. That&#39;s why this is the first section.</p><p>While you&#39;re following this guide, you&#39;re bound to run into the occasional issue or topic that&#39;s lacking detail. The internet will help, but how do you decide which resources are appropriate for your questions? Below, I&#39;ll address the main online resources that <em>I</em> use.</p><div class="tip custom-block"><p class="custom-block-title">Note</p><p>Almost no resource is free of factual inaccuracies: LLMs &#39;<a href="https://www.nature.com/articles/s41586-024-07421-0" target="_blank" rel="noreferrer">hallucinate</a>&#39;, people writing posts on Stack Overflow might have no idea what they&#39;re talking about, and even programmers writing documentation make mistakes.</p></div><h2 id="i-have-a-specific-goal-and-lack-any-background-knowledge" tabindex="-1">I have a specific goal and lack <em>any</em> background knowledge <a class="header-anchor" href="#i-have-a-specific-goal-and-lack-any-background-knowledge" aria-label="Permalink to &quot;I have a specific goal and lack *any* background knowledge&quot;">​</a></h2><p>If you know vaguely what you want to accomplish but <em>nothing</em> about how to accomplish it, I&#39;d recommend googling a recent tutorial. For example, if you&#39;re trying to figure out how to host a website with <a href="https://pages.github.com/" target="_blank" rel="noreferrer">GitHub Pages</a>, read their current documentation or watch a video tutorial rather than going to a forum or using an LLM. This is for two reasons: (1) Forums and LLMs will not always be up-to-date, and (2) they make mistakes that you won&#39;t be able to catch without a little background know-how.</p><h2 id="i-have-a-specific-goal-and-have-a-little-background-knowledge" tabindex="-1">I have a specific goal and have a little background knowledge <a class="header-anchor" href="#i-have-a-specific-goal-and-have-a-little-background-knowledge" aria-label="Permalink to &quot;I have a specific goal and have a little background knowledge&quot;">​</a></h2><p>In this case, LLMs are almost always the best approach. LLM stands for <strong>L</strong>arge <strong>L</strong>anguage <strong>M</strong>odel. These are machine learning models that are trained on vast amounts of text, usually scraped from the internet, to understand, generate, and predict new text. They learn patterns, enabling them to perform a variety of tasks including proof-reading, generating, and answering questions about code.</p><p>Because LLMs are trained on data scraped from the internet, they tend to be better at answering questions with lots of examples to train on. For this reason, LLMs are great at answering common coding questions and writing code in popular languages like Python and Javascript. However, if your question is about something obscure, like a tool that&#39;s only used by the Bloom Lab, you won&#39;t get a useful answer.</p><p>Also, LLMs can &#39;<a href="https://www.nature.com/articles/s41586-024-07421-0" target="_blank" rel="noreferrer">hallucinate</a>&#39; and respond confidently with factually inaccurate answers. For this reason, I only use LLMs when I feel that I can identify these mistakes or I have a way of validating the response.</p><h2 id="helpful-resources" tabindex="-1">Helpful Resources <a class="header-anchor" href="#helpful-resources" aria-label="Permalink to &quot;Helpful Resources&quot;">​</a></h2><p>There are several different LLMs that people use for coding. Personally, I like <a href="https://openai.com/chatgpt/" target="_blank" rel="noreferrer">Open AI&#39;s ChatGPT</a>. It&#39;s a good generalist model that can answer coding questions as well as performing other tasks. I&#39;d recommend the paid model, at the time of writing this it makes a significant difference.</p><p>Another popular LLM that theoretically performs coding tasks better than ChatGPT is <a href="https://www.anthropic.com/claude" target="_blank" rel="noreferrer">Anthropic&#39;s Claude</a>. At the time of writing it&#39;s well liked by several members of the lab.</p><p>Additionally, there are coding specific models like <a href="https://github.com/features/copilot" target="_blank" rel="noreferrer">GitHub&#39;s Copilot</a>. Copilot is nice because it&#39;s integrated directly into the <a href="/bench-to-byte/sections/setting-up-your-ide/">development environment</a> that you write code in giving you suggestions as you go. I use it, but mostly as intelligent autocomplete rather than a resource for asking questions. It&#39;s nice, but not as valuable as ChatGPT or Claude.</p>',14);function u(t,p,g,m,f,w){return s(),o("div",null,[e("h1",c,[n(r(t.$frontmatter.title)+" ",1),h]),d])}const y=a(l,[["render",u]]);export{k as __pageData,y as default};
