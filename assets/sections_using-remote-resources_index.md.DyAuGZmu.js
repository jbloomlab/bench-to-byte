import{_ as a,c as s,m as e,a as t,t as i,V as n,o as c}from"./chunks/framework.rMwTSdrC.js";const f=JSON.parse('{"title":"Section 3: Using remote computing resources","description":"","frontmatter":{"layout":"doc","title":"Section 3: Using remote computing resources","sidebar":true,"aside":true},"headers":[],"relativePath":"sections/using-remote-resources/index.md","filePath":"sections/using-remote-resources/index.md"}'),l={name:"sections/using-remote-resources/index.md"},r={id:"frontmatter-title",tabindex:"-1"},h=e("a",{class:"header-anchor",href:"#frontmatter-title","aria-label":'Permalink to "{{ $frontmatter.title }}"'},"​",-1),d=n(`<p>In this section, I&#39;ll describe how and why we use remote computational resources. I&#39;ll walk you though how to access remote file systems and how to run code on a cluster.</p><h2 id="computing-at-fred-hutch-cancer-center" tabindex="-1">Computing at Fred Hutch Cancer Center <a class="header-anchor" href="#computing-at-fred-hutch-cancer-center" aria-label="Permalink to &quot;Computing at Fred Hutch Cancer Center&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><a href="https://sciwiki.fredhutch.org/scicomputing/comp_index/" target="_blank" rel="noreferrer">This wiki</a> is an invaluable resource for people doing scientific computing at Fred Hutch Cancer Center. It goes in depth on every topic that&#39;s covered in this section.</p></div><p>In the Bloom lab, we use the Fred Hutch Cancer Center&#39;s file system to store our notebooks, data, and code. You can access the file system through a variety of methods. The most common way that people access our lab&#39;s files is by mounting the file system to their computer. This allows you to open and edit these files on your local machine with the advantage that you can navigate through files using a GUI (Graphical User Interface) like Finder on Mac or File Explorer on Windows.</p><p>The shared folders in the file system are all located at <code>/fh/</code>. There are several shared folders including <code>/fh/fast</code>, <code>/fh/scratch</code> and <code>/fh/secure</code>, but our lab&#39;s files are located under <code>/fh/fast</code> in <code>/fh/fast/bloom_j/</code>. Computational projects are stored under <code>/fh/fast/bloom_j/</code> in a directory called <code>computational_notebooks/</code> and organized by the lab member&#39;s Fred Hutch username and the year that a project was started.</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>/fh/fast/bloom_j/computational_notebooks/</span></span>
<span class="line"><span>|</span></span>
<span class="line"><span>|</span></span>
<span class="line"><span>––––– &lt;username&gt;/</span></span>
<span class="line"><span>    |</span></span>
<span class="line"><span>    |</span></span>
<span class="line"><span>    ––––– &lt;year&gt;/</span></span>
<span class="line"><span>        |</span></span>
<span class="line"><span>        |</span></span>
<span class="line"><span>        ––––– &lt;project&gt;/</span></span></code></pre></div><p>For example, if I have a project called <code>HMPV-Antibody-Passaging</code> that I created in 2024, it&#39;s location on the file system should be <code>/fh/fast/bloom_j/computational_notebooks/whannon/2024/HMPV-Antibody-Passaging</code>. Aside from the organizational benefits of adhering to this convention, all of the <em>code</em> in <code>/fh/fast/bloom_j/computational_notebooks/</code> is automatically backed up on a daily basis.</p><h2 id="access-through-the-command-line" tabindex="-1">Access through the command line <a class="header-anchor" href="#access-through-the-command-line" aria-label="Permalink to &quot;Access through the command line&quot;">​</a></h2><p>In addition to mounting the file system to your local computer as a network drive, you can connect to the file system by accessing a remote computer cluster called <code>Rhino</code>. <code>Rhino</code> is a cluster of 3 large memory, shared computers that are intended for interactively prototyping and writing code. You can use <code>Rhino</code> to execute code to analyze your data, however, <code>Rhino</code> is <strong>not</strong> intended for intensive computational tasks (like aligning sequencing reads). Fred Hutch has a <a href="#computationally-intensive-computing-with-gizmo">separate computer cluster called <code>Gizmo</code></a> for intensive tasks.</p><h3 id="logging-into-rhino" tabindex="-1">Logging into <code>Rhino</code> <a class="header-anchor" href="#logging-into-rhino" aria-label="Permalink to &quot;Logging into \`Rhino\`&quot;">​</a></h3><p>You log into <code>Rhino</code> through the command line or shell. If you&#39;re not familiar with the command line, check out this <a href="https://missing.csail.mit.edu/2020/course-shell/" target="_blank" rel="noreferrer">excellent tutorial</a>.</p><p>Log into <code>Rhino</code> by opening up the command line and typing the <code>ssh</code> command.</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ssh</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> username@rhino</span></span></code></pre></div><p>You&#39;ll be prompted to enter your Fred Hutch password. Note, you can only access <code>Rhino</code> like this while using the Fred Hutch wifi. You can log into <code>Rhino</code> without being on the wifi, but that requires an <a href="#setting-up-a-proxy-jump">alternative method described in a later section</a>. Now, you&#39;ll see that your terminal&#39;s prompt has changed to something like <code>username@rhino02:~$ </code>, and commands that you run from the command line will be executed by <code>Rhino</code>.</p><p>When you initially connect to <code>Rhino</code>, you&#39;re location on the file system is a special &#39;home&#39; directory that&#39;s specific to each user and located at <code>/home/username</code>. We&#39;ll use this home directory <a href="/bench-to-byte/sections/managing-software-environments/">later</a>, but for now, most of our code and data should be located in the Bloom lab&#39;s directory (<code>/fh/fast/bloom_j/</code>). We could move there by navigating to our computational notebook like so.</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /fh/fast/bloom_j/computational_notebooks/username/</span></span></code></pre></div><p>But, it becomes annoying if you have to remember the full path every time you log onto <code>Rhino</code>. Instead, we can make our lives a little easier with &#39;symbolic links&#39;. These are a way of making shortcuts between places on the file system. Instead of typing the full path each time, we can type a shortened version and it will jump us to the correct location.</p><p>Run the following command to make a symbolic link to your computational notebook.</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ln</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -s</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> fh/fast/bloom_j/computational_notebooks/username/ username/</span></span></code></pre></div><p>Now, you can access your folder in <code>computational_notebooks</code> from <em>either</em> it&#39;s original path (<code>cd fh/fast/bloom_j/computational_notebooks/username</code>) or a new path from your home directory (<code>cd ~/username</code>). Both paths will take you to the same place.</p><h3 id="setting-up-ssh-keys" tabindex="-1">Setting up SSH keys <a class="header-anchor" href="#setting-up-ssh-keys" aria-label="Permalink to &quot;Setting up SSH keys&quot;">​</a></h3><p>The approach <a href="#logging-into-rhino">outlined above</a> is a perfectly good way to log into <code>Rhino</code>, but entering your password each time gets annoying. Instead, I&#39;d recommend setting up SSH to be password-free using SSH keys. This will allow you to log in securely without needing to enter your password every time.</p><p>SSH keys are a pair of cryptographic keys (one <em>public</em>, one <em>private</em>) used to authenticate your identity when connecting to a remote server like <code>Rhino</code>. The private key stays on your local machine and is kept secret, while the public key is placed with the server. When you log in, the server checks that the private key on your machine matches the public key it has, allowing you to authenticate without needing to enter a password.</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>The process for generating SSH keys differs between operating systems. The following steps apply to a local computer with Mac OS and a remote computer with Ubuntu Linux (<code>Rhino</code>). There are tons of tutorials online for setting up SSH keys if your computer has a different operating system.</p></div><h4 id="step-1-generate-an-ssh-key-pair" tabindex="-1">Step 1: Generate an SSH Key Pair <a class="header-anchor" href="#step-1-generate-an-ssh-key-pair" aria-label="Permalink to &quot;Step 1: Generate an SSH Key Pair&quot;">​</a></h4><p>First, you&#39;ll need to generate a pair of SSH keys on your local machine. To do this, open a terminal (make sure you&#39;re <strong>not</strong> logged into <code>Rhino</code>) and run the following command:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ssh-keygen</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -t</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> rsa -b </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4096</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> -C &quot;rhino.fhcrc.org&quot;</span></span></code></pre></div><ul><li><code>-t rsa</code> specifies that you&#39;re generating an RSA key.</li><li><code>-b 4096</code> generates a 4096-bit key for added security.</li><li><code>-C &quot;rhino.fhcrc.org&quot;</code> adds an optional label (in this case, the name of the remote host) to help identify your key.</li></ul><p>When you&#39;re be prompted for a file location, press <code>Enter</code> to select the default (<code>~/.ssh/id_rsa</code>). When you&#39;re prompted to enter an optional passphrase, also press <code>Enter</code> to skip this step.</p><h4 id="step-2-copy-the-public-key-to-rhino" tabindex="-1">Step 2: Copy the public key to <code>Rhino</code> <a class="header-anchor" href="#step-2-copy-the-public-key-to-rhino" aria-label="Permalink to &quot;Step 2: Copy the public key to \`Rhino\`&quot;">​</a></h4><p>Now you&#39;ll have two keys located at <code>~/.ssh/id_rsa</code>, one public and one private. Copy the <strong>public</strong> key to <code>Rhino</code> using the following command:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ssh-copy-id</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> username@rhino</span></span></code></pre></div><p>Your public SSH key will now be on <code>Rhino</code> in <code>~/.ssh/authorized_keys</code> where <code>~</code> is your home directory on the server (<code>/home/username</code>).</p><h4 id="step-3-log-in-to-make-sure-it-worked" tabindex="-1">Step 3: Log in to make sure it worked <a class="header-anchor" href="#step-3-log-in-to-make-sure-it-worked" aria-label="Permalink to &quot;Step 3: Log in to make sure it worked&quot;">​</a></h4><p>You should be able to log into <code>Rhino</code> without a password now. Test it out:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ssh</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> username@rhino</span></span></code></pre></div><p>If everything worked, you won&#39;t be prompted for a password.</p><h4 id="step-4-edit-your-ssh-config" tabindex="-1">Step 4: Edit your SSH config <a class="header-anchor" href="#step-4-edit-your-ssh-config" aria-label="Permalink to &quot;Step 4: Edit your SSH config&quot;">​</a></h4><p>This step is optional, but it will make life easier down the road. Make a new file called &#39;config&#39; (no extension) in <code>~/ssh/</code> on your local machine and add the following line:</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>Host rhino</span></span>
<span class="line"><span>  HostName rhino</span></span>
<span class="line"><span>  User username</span></span>
<span class="line"><span>  ForwardX11 yes</span></span>
<span class="line"><span>  ForwardAgent yes</span></span>
<span class="line"><span>  ForwardX11Trusted yes</span></span>
<span class="line"><span>  IdentityFile ~/.ssh/id_rsa</span></span></code></pre></div><h3 id="setting-up-a-proxy-jump" tabindex="-1">Setting up a proxy jump <a class="header-anchor" href="#setting-up-a-proxy-jump" aria-label="Permalink to &quot;Setting up a proxy jump&quot;">​</a></h3><p>So far, the approaches detailed above will only work when you&#39;re on the Fred Hutch wifi. But what about if you&#39;re working from home and you want to access the sever? The simplest option is to log into the Fred Hutch VPN from a Fred Hutch managed computer and log into <code>Rhino</code> like you normally would. However, if you don&#39;t have a Fred Hutch managed computer, this won&#39;t work. In that case, the other option is to use a &#39;proxy jump&#39;.</p><p>A proxy jump involves logging into <code>Rhino</code> through an intermediate host called <code>Snail</code>. First you log into <code>Snail</code>, then from <code>Snail</code> you log into <code>Rhino</code>. Thankfully, we can automate this process using SSH keys and the SSH config. <a href="https://sciwiki.fredhutch.org/scicomputing/access_methods/#remote-access" target="_blank" rel="noreferrer">Here&#39;s a detailed tutorial</a> on setting up a proxy jump to <code>Rhino</code> with <code>Snail</code>.</p><h3 id="computationally-intensive-computing-with-gizmo" tabindex="-1">Computationally intensive computing with <code>Gizmo</code> <a class="header-anchor" href="#computationally-intensive-computing-with-gizmo" aria-label="Permalink to &quot;Computationally intensive computing with \`Gizmo\`&quot;">​</a></h3><p>The <code>Rhino</code> cluster is intended for accessing and manipulating files, running and developing programs, managing software environments, and interactive coding. It&#39;s <strong>not</strong> intended running for computationally intensive jobs (such as aligning sequencing reads) that take a long time or use many CPUs. For those kinds of jobs, we use the <code>Gizmo</code> cluster. Like <code>Rhino</code>, <code>Gizmo</code> is a computer cluster managed by Fred Hutch; unlike <code>Rhino</code>, it&#39;s very, very large.</p><p>There are two methods of running programs on <code>Gizmo</code>: (1) <a href="#using-gizmo-with-slurm">submitting them as jobs with <code>Slurm</code></a> or (2) <a href="#using-gizmo-interactively">running them interactively with <code>grabnode</code></a>. I&#39;ll discuss both below.</p><div class="tip custom-block"><p class="custom-block-title">Note</p><p>If you&#39;ve never used <code>Gizmo</code> before, you&#39;ll need to ask Fred Hutch Scicomp for permission. Shoot them a quick email and you&#39;ll usually hear back within an hour.</p></div><h4 id="using-gizmo-interactively" tabindex="-1">Using <code>Gizmo</code> interactively <a class="header-anchor" href="#using-gizmo-interactively" aria-label="Permalink to &quot;Using \`Gizmo\` interactively&quot;">​</a></h4><p>This is the easiest way to get access to <code>Gizmo</code>. Log into <code>Rhino</code> and type:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">grabnode</span></span></code></pre></div><p>You&#39;ll be prompted with several questions including how many CPU you want, how much memory you need, how much time you need, and whether you need a GPU. It can take a few minutes for the system to allocate you resources. When it&#39;s done, you&#39;ll see that you&#39;re prompt has changed from something like <code>username@rhino02:~$ </code> to <code>username@gizmok3:~$ </code>. Now, anything you type into the command line will be run on the <code>Gizmo</code> cluster.</p><p>This is a great approach for troubleshooting computationally intensive tasks interactively. However, it&#39;s not a good approach for running jobs you expect to take a long time. The resources you request from <code>Gizmo</code> will be released when you log out. That means that any job that&#39;s running will be terminated if you log out or lose connection to the server. There&#39;s a way to <a href="#using-tmux">get around this constraint with <code>tmux</code></a>, but it&#39;s better to submit long-running jobs with <a href="#using-gizmo-with-slurm"><code>Slurm</code></a>.</p><h4 id="using-gizmo-with-slurm" tabindex="-1">Using <code>Gizmo</code> with <code>Slurm</code> <a class="header-anchor" href="#using-gizmo-with-slurm" aria-label="Permalink to &quot;Using \`Gizmo\` with \`Slurm\`&quot;">​</a></h4><p>This is the more common use case for <code>Gizmo</code>. If you have a long-running computationally-intensive job, for example, a <a href="./.html">Snakemake pipeline</a> that performs many sequencing alignments, you can submit a &#39;job&#39; to <code>Gizmo</code> and the code will run until it&#39;s finished. You&#39;re using the resources of <code>Gizmo</code> just <a href="#using-gizmo-interactively">like you do above</a>, but you don&#39;t need to leave <code>Rhino</code> and your jobs will keep running if you log out.</p><p><code>Gizmo</code> uses a program called <code>Slurm</code> to handle job submission. <code>Slurm</code> (Simple Linux Utility for Resource Management) is an open-source job scheduling system used for managing and allocating computing resources in a cluster.</p><ol><li><strong>Submitting a Job</strong></li></ol><p>To submit a job in Slurm, you use the <code>sbatch</code> command with a job script. The script contains the commands you want to run and <code>Slurm</code> directives to request resources. A simple bash script (<code>run_job.bash</code>) looks like this:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#!/bin/bash</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#SBATCH -c 16</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">snakemake</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -j</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 16</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> --software-deployment-method conda -s dms-vep-pipeline-3/Snakefile</span></span></code></pre></div><p>The comments starting with <code>#SBATCH</code> configure <code>Slurm</code> by providing arguments like how many CPUs you need (<code>#SBATCH -c 16</code>). You submit the job script to <code>Slurm</code> using the <code>sbatch</code> command as follows:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sbatch</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run_job.bash</span></span></code></pre></div><p>You can check on the status of your jobs running on <code>Gizmo</code> with the <code>squeue</code> command. This command shows you the jobs you have running and how long they&#39;ve been running for.</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">squeue</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -u</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> username</span></span></code></pre></div><p>If you want to cancel a job that&#39;s running, use the <code>scancel</code> command.</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">scancel</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -u</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> username</span></span></code></pre></div><p>There&#39;s <a href="https://slurm.schedmd.com/documentation.html" target="_blank" rel="noreferrer">a lot more to <code>Slurm</code></a>, but that&#39;s most of what you&#39;ll need to know.</p><h3 id="using-tmux" tabindex="-1">Using <code>tmux</code> <a class="header-anchor" href="#using-tmux" aria-label="Permalink to &quot;Using \`tmux\`&quot;">​</a></h3><p>As I mentioned above, you may run into a scenario where you want to run something interactively and you don&#39;t want the process to terminate when you log off the server. That&#39;s where <code>tmux</code> comes in handy. <code>tmux</code> (Terminal Multiplexer) is software that&#39;s pre-loaded on <code>Rhino</code> and <code>Gizmo</code>. It allows you to create multiple terminal sessions within a single window, and more importantly, lets you <em>detach</em> from a session while keeping it running in the background. This way, you can log off and later reconnect to the session to check on your processes or pick up where you left off.</p><h4 id="_1-start-a-new-session" tabindex="-1">1. Start a new session <a class="header-anchor" href="#_1-start-a-new-session" aria-label="Permalink to &quot;1. Start a new session&quot;">​</a></h4><p>To start a new <code>tmux</code> session, use the command:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">tmux</span></span></code></pre></div><p>This opens a new terminal window with a little green bar at the bottom. You&#39;d use this terminal as you would normally.</p><h4 id="_2-detach-from-a-session" tabindex="-1">2. Detach from a session <a class="header-anchor" href="#_2-detach-from-a-session" aria-label="Permalink to &quot;2. Detach from a session&quot;">​</a></h4><p>To detach from a session and leave it running, press <code>Ctrl + B</code>, followed by <code>D</code>. This will bring you back to your original terminal prompt, but your <code>tmux</code> session will continue to run in the background.</p><h4 id="_3-list-active-sessions" tabindex="-1">3. List active sessions <a class="header-anchor" href="#_3-list-active-sessions" aria-label="Permalink to &quot;3. List active sessions&quot;">​</a></h4><p>If you want to see a list of all the running tmux sessions, use:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">tmux</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ls</span></span></code></pre></div><h4 id="_4-reattach-to-a-session" tabindex="-1">4. Reattach to a session <a class="header-anchor" href="#_4-reattach-to-a-session" aria-label="Permalink to &quot;4. Reattach to a session&quot;">​</a></h4><p>To reattach to a session you previously detached from, use:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">tmux</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> attach -t </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">session_i</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div><p>Replace &lt;session_id&gt; with the number or name (if you named it) of the session you want to reconnect to, which can be found using the <code>tmux ls</code> command.</p><h4 id="_5-kill-a-session" tabindex="-1">5. Kill a session <a class="header-anchor" href="#_5-kill-a-session" aria-label="Permalink to &quot;5. Kill a session&quot;">​</a></h4><p>When you&#39;re done, you can kill a <code>tmux</code> session by typing exit within the session or by pressing <code>Ctrl + D</code>.</p>`,82);function p(o,u,m,g,y,k){return c(),s("div",null,[e("h1",r,[t(i(o.$frontmatter.title)+" ",1),h]),d])}const w=a(l,[["render",p]]);export{f as __pageData,w as default};
